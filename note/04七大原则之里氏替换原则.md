OO中的继承性的思考：

1. 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然他不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏
2. 继承在给程序带来便利的同时，也带来了弊端。如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性。如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障
3. 在编程中，如何正确的使用继承？ **->里氏替换原则**


### 基本介绍

1. 里氏替换原则（Liskov Substitution Principle），在1988年，由麻省理工学院的一位姓里的女士提出
2. 如果对每个类型为T1的对象O1，都有类型为T2的对象O2，使得以T1定义的所有程序P在所有的对象O1都代换成O2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象
3. 在使用继承时，遵循里氏替换原则，**在子类中尽量不要重写父类的方法**
4. 里氏替换原则告诉我们，继承实际上让两个类的耦合性增强了，**在适当的情况下，可以通过聚合，组合，依赖来解决问题**


### 应用实例
```java
/**
 * Created with IntelliJ IDEA.
 * User: Mingda
 * Time: 2024/2/26 16:41
 * File: Liskov
 * Description: 里氏替换原则
 */
public class Liskov {

    public static void main(String[] args) {
        A a = new A();
        System.out.println("1 - 2 = " + a.func1(1, 2));

        System.out.println("==============================");

        B b = new B();
        // 本意是 1-2
        System.out.println("1 - 2 = " + b.func1(1, 2));
    }
}

// A类
class A {
    // 返回两数之差
    public int func1(int num1, int num2) {
        return num1 - num2;
    }
}

// B类
// 增加了新功能：两数之和，再与9相加
class B extends A {
    // 这里重写了A类的func1方法，可能时无意识不小心的
    public int func1(int num1, int num2) {
        return num1 + num2;
    }

    public int func2(int num1, int num2) {
        return func1(num1, num2) + 9;
    }
}
```
运行结果：功能出错，原本相减变成了求和
```java
1 - 2 = -1
==============================
1 - 2 = 3
```

解决办法：

1. 发现原来运行正常的相减功能出错。原因是B类无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样虽然便捷，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候
2. 通用的做法是：**原来的父类和子类都继承一个更通俗的基类，去掉原有的继承，采用依赖，聚合，组合等关系代替**

![](https://cdn.nlark.com/yuque/0/2024/jpeg/35841438/1708939013028-c12baea7-703a-458e-ae8c-441c65bbf0ee.jpeg)
```java
package com.jmd.principle.liskov.improve;

/**
 * Created with IntelliJ IDEA.
 * User: Mingda
 * Time: 2024/2/26 16:41
 * File: Liskov
 * Description: 里氏替换原则
 */
public class Liskov {

    public static void main(String[] args) {
        A a = new A();
        System.out.println("1 - 2 = " + a.func1(1, 2));

        System.out.println("==============================");

        B b = new B();
        // B不再继承A类，b.func1不再是求减法
        // 本意是 1+2，调用功能明确
        System.out.println("1 + 2 = " + b.func1(1, 2));
        // 使用组合仍然可以使用到A的方法
        System.out.println("10 - 1 = " + b.func3(10, 1));
    }
}

// 创建一个更基础的类
class Base {
    // 将更基础的方法和成员写到Base类
}

// A类
class A extends Base{
    // 返回两数之差
    public int func1(int num1, int num2) {
        return num1 - num2;
    }
}

// B类
// 增加了新功能：两数之和，再与9相加
class B extends Base {
    // 如果B需要使用A类的方法，使用组合关系
    private A a = new A();

    // 这里的func1方法，是B类的，与A类无关
    public int func1(int num1, int num2) {
        return num1 + num2;
    }

    public int func2(int num1, int num2) {
        return func1(num1, num2) + 9;
    }

    // 仍然想使用A的方法
    public int func3(int num1, int num2) {
        return a.func1(num1, num2);
    }
}
```
