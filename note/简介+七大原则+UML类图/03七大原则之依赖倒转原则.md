依赖倒转原则（Dependence Inversion Principle）
<a name="gbGio"></a>
### 基本介绍

1. 高层模块不应该依赖低层模块，二者都应该依赖其抽象（接口/抽象类）
2. **抽象不应该依赖细节，细节应该依赖抽象**
3. 依赖倒转（倒置）的中心思想是**面向接口编程**
4. 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。在Java中，抽象指的是接口或抽象类，细节就是具体的实现类
5. 使用**接口或抽象类**的目的是制定好**规范**，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成
```java
/**
 * Created with IntelliJ IDEA.
 * User: Mingda
 * Time: 2024/2/26 11:26
 * File: DependecyInversion
 * Description: 依赖倒转原则
 */
public class DependencyInversion {

    public static void main(String[] args) {
        Persion persion = new Persion();
        persion.receive(new Email());
    }
}

class Email {
    public String getInfo() {
        return "email: hello!";
    }
}

/**
 * 完成Persion接收消息的功能
 * 方式1:
 * 1. 简单，容易实现
 * 2. 如果我们获取的对象是微信，短信等，则需新增类，同时Persion类也需要添加相应的接收方法
 * 3. 解决思路：引入一个抽象接口IReceive，表示接收者，这样Persion类与接口发生依赖关系。Email、微信、短信等各自实现IReceive接口，符合依赖倒转原则
 */
class Persion {
    public void receive(Email email) {
        System.out.println(email.getInfo());
    }
}

```
```java
/**
 * Created with IntelliJ IDEA.
 * User: Mingda
 * Time: 2024/2/26 11:26
 * File: DependecyInversion
 * Description: 依赖倒转原则
 */
public class DependencyInversion {

    public static void main(String[] args) {
        // 客户端无需改变
        Persion persion = new Persion();
        persion.receive(new Email());
        persion.receive(new WeChat());
    }
}

// 定义一个接口
interface IReceiver {
    public String getInfo();
}

// Email
class Email implements IReceiver {
    public String getInfo() {
        return "email: hello!";
    }
}

// 微信
class WeChat implements IReceiver {
    public String getInfo() {
        return "wechat: hello!";
    }
}

/**
 * 方式2
 */
class Persion {
    // 对接口的依赖
    public void receive(IReceiver receiver) {
        System.out.println(receiver.getInfo());
    }
}
```
<a name="L6jP5"></a>
### 依赖关系传递的三种关系

1. 接口传递
2. 构造方法传递
3. setter方式传递
```java
/**
 * Created with IntelliJ IDEA.
 * User: Mingda
 * Time: 2024/2/26 15:29
 * File: DependencyPass
 * Description:
 */
public class DependencyPass {

    public static void main(String[] args) {

        ChangHong tv = new ChangHong();

        // 方式1
//        OpenAndClose openAndClose = new OpenAndClose();
//        openAndClose.open(tv);

        // 方式2
//        OpenAndClose openAndClose = new OpenAndClose(tv);
//        openAndClose.open();

        // 方式3
        OpenAndClose openAndClose = new OpenAndClose();
        openAndClose.setTv(tv);
        openAndClose.open();

    }
}

//// 方式1：通过接口传递实现依赖
//// 开关的接口
//interface IOpenAndClose {
//    public void open(ITV tv);
//}
//
//// ITV接口
//interface ITV {
//    public void play();
//}
//
//class ChangHong implements ITV {
//    public void play() {
//        System.out.println("ChangHong is playing");
//    }
//}
//
//// 实现接口
//class OpenAndClose implements IOpenAndClose {
//    public void open(ITV tv) {
//        tv.play();
//    }
//}

//// 方式2：通过构造方法依赖传递
//interface IOpenAndClose {
//    public void open();
//}
//
//interface ITV {
//    public void play();
//}
//
//class ChangHong implements ITV {
//    public void play() {
//        System.out.println("ChangHong is playing");
//    }
//}
//
//class OpenAndClose implements IOpenAndClose {
//    private ITV tv;
//
//    public OpenAndClose(ITV tv) {
//        this.tv = tv;
//    }
//
//    public void open() {
//        tv.play();
//    }
//}

// 方式3：通过setter方法传递
interface IOpenAndClose {
    public void open();
    public void setTv(ITV tv);
}

interface ITV {
    public void play();
}

class ChangHong implements ITV {
    public void play() {
        System.out.println("ChangHong is playing");
    }
}

class OpenAndClose implements IOpenAndClose {
    private ITV tv;

    public void setTv(ITV tv) {
        this.tv = tv;
    }

    public void open() {
        tv.play();
    }
}
```
<a name="GvYTk"></a>
### 注意事项和细节

1. 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好
2. 变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化
3. 继承时遵循里氏替换原则
